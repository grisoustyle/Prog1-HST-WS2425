**Theoriefragen und Antworten**

### 1. Beispiele für festprogrammierte und speicherprogrammierte Rechner & fundamentale Unterschiede
- **Festprogrammierter Rechner:** Ein Beispiel ist ein Taschenrechner oder ein spezieller Mikrocontroller in Haushaltsgeräten.
- **Speicherprogrammierter Rechner:** Ein PC oder ein Smartphone, das Programme ausführt.

**Unterschiede:**
- Festprogrammierte Rechner haben ihre Funktionen fest verdrahtet und können nicht umprogrammiert werden.
- Speicherprogrammierte Rechner können durch Software beliebig neu programmiert werden.

### 2. Vorteile festprogrammierter Rechner & Einsatzbereiche
**Vorteile:**
- Geringerer Energieverbrauch
- Höhere Geschwindigkeit für spezifische Aufgaben
- Stabilität und Zuverlässigkeit

**Einsatzbereiche:**
- Industrieautomatisierung
- Eingebettete Systeme (z. B. ABS in Autos)

### 3. Turing-Vollständigkeit & Auswirkungen auf Programmiersprachen
- Eine **Turing-vollständige** Programmiersprache kann jede berechenbare Funktion ausdrücken.
- **Auswirkung:** In der Praxis bedeutet das, dass alle gängigen Programmiersprachen universell einsetzbar sind.

### 4. Computational Thinking am Alltagsbeispiel
- **Definition:** Problemlösung mit den Prinzipien der Informatik.
- **Beispiel:** Planung eines Einkaufs – Zerlegen des Problems (Was brauche ich?), Mustererkennung (Was kaufe ich regelmäßig?), Algorithmus (Weg durch den Supermarkt optimieren).

### 5. Problemraum vs. Lösungsraum
- **Problemraum:** Die Menge aller möglichen Probleme und Anforderungen.
- **Lösungsraum:** Die Menge aller möglichen Lösungen und deren Umsetzung.

### 6. Von-Neumann-Architektur – fehlende Komponenten
1. **Speicher:** Speichert Programme und Daten.
2. **Rechenwerk (ALU):** Führt arithmetische Operationen aus.
3. **Steuerwerk (Control Unit):** Interpretiert Befehle.

### 7. Deklarative vs. Imperative Programmiersprachen
- **Deklarativ (WAS?):** SQL, Prolog (man beschreibt das Ziel).
- **Imperativ (WIE?):** C, Python (man beschreibt den Lösungsweg).
- **Vorteile:** Deklarativ erleichtert Wartung, imperativ gibt mehr Kontrolle.

### 8. Unlösbare Probleme & praktische Nutzung
- **Beispiele:** Wettervorhersage, Verschlüsselung.
- **Nutzen:** Sicherheit in der Kryptographie.
- **Wegfall des Defizits:** Verschlüsselung wäre nicht mehr sicher.

### 9. Turing-Maschine – Bestandteile & Bedeutung
- **Bestandteile:** Band, Lese-/Schreibkopf, Steuerwerk.
- **Operationen:** Lesen, Schreiben, Bewegen.
- **Bedeutung:** Grundlage aller modernen Computer.

### 10. Algorithmus – Bestandteile
1. Sequenz von Einzelschritten
2. Kontrollfluss
3. Abbruchkriterium

---

## **Ankreuzaufgaben: Problemraum vs. Lösungsraum**

| Aufgabe | Problemraum | Lösungsraum |
|---------|------------|------------|
| Entwicklung unter Verwendung einer bestimmten Programmiersprache (z.B. Python) |   | ✅ |
| Erstellung des Domänenmodells | ✅ |   |
| Entscheidung für eine bestimmte Cloud-Infrastruktur (z.B. AWS) |   | ✅ |
| Analyse der Komplexität einer zu lösenden Aufgabe | ✅ |   |
| Implementierung eines Prototyps |   | ✅ |
| Dokumentation der nicht-funktionalen Anforderungen | ✅ |   |
| Sammeln, Definieren und Verstehen der Benutzeranforderungen | ✅ |   |
| Identifikation potenzieller Risiken, Abhängigkeiten und Interessen von Stakeholdern, die das Projekt beeinflussen könnten | ✅ |   |
| Implementieren und Testen gemäß Anforderungen |   | ✅ |
| Auswahl geeigneter Programmiersprachen, Frameworks und Tools, die zur Lösung des Problems eingesetzt werden |   | ✅ |
| Erstellen des Systemdesigns, einschließlich Architektur, Datenmodellierung und Schnittstellendesign | ✅ |   |
| Erstellung von Benutzerszenarien, Use-Case-Beschreibungen und funktionalen Spezifikationen | ✅ |   |

**Erklärung:**  
- **Problemraum** umfasst die Analyse und Definition des Problems, Anforderungen und Einschränkungen.  
- **Lösungsraum** beinhaltet die konkrete Umsetzung, Technologien und Implementierungsschritte.

